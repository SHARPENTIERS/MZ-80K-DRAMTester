ORG 			$0000

; -----------------------------------------------------------------------------
; Definitions
; -----------
CHRMAP			"DISPLAYCODE-EU"

; -----------------------------------------------------------------------------
; Main entry
; ----------
mrom_main:
		; No interrupt
		DI
		LD		SP,$E000

		; Draw test screen #0
loop:	LD		HL,vram_test_screen0
		LD		DE,$D000
		CALL	dzx0_standard

@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b

		CALL	wait_space_bar
		
		; Draw DRAM screen
		LD		HL,vram_dram_screen
		LD		DE,$D000
		CALL	dzx0_standard

loop0:	LD		HL,$D000
		LD		(HL),32

		CALL	wait_vsync

		; Check DRAM chips in area $1000-$4FFF - DRAM (I)
check_dram_row_I_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$5000
		LD		HL,$1000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_I

		; Check DRAM chips in area $5000-$9FFF - DRAM (II)
check_dram_row_II_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$A000
		LD		HL,$5000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_II

		; Check DRAM chips in area $A000-$CFFF - DRAM (III)
check_dram_row_III_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$D000
		LD		HL,$A000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_III

@@:		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		Z,loop0

		; Draw test screen #1
		LD		HL,vram_test_screen1
		LD		DE,$D000
		CALL	dzx0_standard

@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b

		CALL	wait_space_bar

		; Draw DRAM screen
		LD		HL,vram_dram_screen
		LD		DE,$D000
		CALL	dzx0_standard

loop1:	LD		HL,$D000
		LD		(HL),32

		CALL	wait_vsync
		
		; Check DRAM chips in area $1000-$4FFF - DRAM (I)
check_dram_row_I_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$5000
		LD		HL,$1000
		CALL	check_dram_row_Match_C  
		CALL	draw_dram_row_I

		; Check DRAM chips in area $5000-$9FFF - DRAM (II)
check_dram_row_II_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$A000
		LD		HL,$5000
		CALL	check_dram_row_Match_C
		CALL	draw_dram_row_II

		; Check DRAM chips in area $A000-$CFFF - DRAM (III)
check_dram_row_III_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$D000
		LD		HL,$A000
		CALL	check_dram_row_Match_C
		CALL	draw_dram_row_III

@@:		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		Z,loop1

		JP		loop

draw_dram_row_I:
		LD		DE,$476D ; XO
		BIT		0,C
		LD		HL,$D000+(2*40)+34	; BIT D0 is OK/KO
		LD		A,D
		JR		Z,@0f
		LD		A,E
@0:		LD		(HL),A
		BIT		1,C
		LD		HL,$D000+(5*40)+34	; BIT D1 is OK/KO
		LD		A,D
		JR		Z,@1f
		LD		A,E
@1:		LD		(HL),A
		BIT		2,C
		LD		HL,$D000+(8*40)+34	; BIT D2 is OK/KO
		LD		A,D
		JR		Z,@2f
		LD		A,E
@2:		LD		(HL),A
		BIT		3,C
		LD		HL,$D000+(11*40)+34	; BIT D3 is OK/KO
		LD		A,D
		JR		Z,@3f
		LD		A,E
@3:		LD		(HL),A
		BIT		4,C
		LD		B,$C1
		LD		HL,$D000+(14*40)+34	; BIT D4 is OK/KO
		LD		A,D
		JR		Z,@4f
		LD		A,E
@4:		LD		(HL),A
		BIT		5,C
		LD		HL,$D000+(17*40)+34	; BIT D5 is OK/KO
		LD		A,D
		JR		Z,@5f
		LD		A,E
@5:		LD		(HL),A
		BIT		6,C
		LD		HL,$D000+(20*40)+34	; BIT D6 is OK/KO
		LD		A,D
		JR		Z,@6f
		LD		A,E
@6:		LD		(HL),A
		BIT		7,C
		LD		HL,$D000+(23*40)+34	; BIT D7 is OK/KO
		LD		A,D
		JR		Z,@7f
		LD		A,E
@7:		LD		(HL),A
		RET

draw_dram_row_II:
		LD		DE,$476D ; XO
		BIT		0,C
		LD		HL,$D000+(2*40)+23	; BIT D0 is OK/KO
		LD		A,D
		JR		Z,@0f
		LD		A,E
@0:		LD		(HL),A
		BIT		1,C
		LD		HL,$D000+(5*40)+23	; BIT D1 is OK/KO
		LD		A,D
		JR		Z,@1f
		LD		A,E
@1:		LD		(HL),A
		BIT		2,C
		LD		HL,$D000+(8*40)+23	; BIT D2 is OK/KO
		LD		A,D
		JR		Z,@2f
		LD		A,E
@2:		LD		(HL),A
		BIT		3,C
		LD		HL,$D000+(11*40)+23	; BIT D3 is OK/KO
		LD		A,D
		JR		Z,@3f
		LD		A,E
@3:		LD		(HL),A
		BIT		4,C
		LD		B,$C1
		LD		HL,$D000+(14*40)+23	; BIT D4 is OK/KO
		LD		A,D
		JR		Z,@4f
		LD		A,E
@4:		LD		(HL),A
		BIT		5,C
		LD		HL,$D000+(17*40)+23	; BIT D5 is OK/KO
		LD		A,D
		JR		Z,@5f
		LD		A,E
@5:		LD		(HL),A
		BIT		6,C
		LD		HL,$D000+(20*40)+23	; BIT D6 is OK/KO
		LD		A,D
		JR		Z,@6f
		LD		A,E
@6:		LD		(HL),A
		BIT		7,C
		LD		HL,$D000+(23*40)+23	; BIT D7 is OK/KO
		LD		A,D
		JR		Z,@7f
		LD		A,E
@7:		LD		(HL),A
		RET

draw_dram_row_III:
		LD		DE,$476D ; XO
		BIT		0,C
		LD		HL,$D000+(2*40)+11	; BIT D0 is OK/KO
		LD		A,D
		JR		Z,@0f
		LD		A,E
@0:		LD		(HL),A
		BIT		1,C
		LD		HL,$D000+(5*40)+11	; BIT D1 is OK/KO
		LD		A,D
		JR		Z,@1f
		LD		A,E
@1:		LD		(HL),A
		BIT		2,C
		LD		HL,$D000+(8*40)+11	; BIT D2 is OK/KO
		LD		A,D
		JR		Z,@2f
		LD		A,E
@2:		LD		(HL),A
		BIT		3,C
		LD		HL,$D000+(11*40)+11	; BIT D3 is OK/KO
		LD		A,D
		JR		Z,@3f
		LD		A,E
@3:		LD		(HL),A
		BIT		4,C
		LD		B,$C1
		LD		HL,$D000+(14*40)+11	; BIT D4 is OK/KO
		LD		A,D
		JR		Z,@4f
		LD		A,E
@4:		LD		(HL),A
		BIT		5,C
		LD		HL,$D000+(17*40)+11	; BIT D5 is OK/KO
		LD		A,D
		JR		Z,@5f
		LD		A,E
@5:		LD		(HL),A
		BIT		6,C
		LD		HL,$D000+(20*40)+11	; BIT D6 is OK/KO
		LD		A,D
		JR		Z,@6f
		LD		A,E
@6:		LD		(HL),A
		BIT		7,C
		LD		HL,$D000+(23*40)+11	; BIT D7 is OK/KO
		LD		A,D
		JR		Z,@7f
		LD		A,E
@7:		LD		(HL),A
		RET

wait_vsync:
		LD		HL,$E002
		LD		A,$7F					; C = ($E002) > $7F <=> $E002.bit7 == 0
@@:		CP		(HL)					; poll /VBLK until it becomes low (asserted)
		JP		C,@b
		RET

wait_space_bar:
@@:		CALL	kbd_read_space			; wait for holding [SPACE]
		JR		Z,@b
@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b
		RET

check_dram_row_55_AA_RW:
@0:		LD		(HL),$55
		INC		HL
		LD		(HL),$AA
		DEC		HL
		LD		A,(HL)
		XOR		$55
		OR		C
		LD		C,A
		INC		HL
		LD		A,(HL)
		XOR		$AA
		OR		C
		LD		C,A
		DEC		HL
		LD		(HL),$AA
		INC		HL
		LD		(HL),$55
		DEC		HL
		LD		A,(HL)
		XOR		$AA
		OR		C
		LD		C,A
		INC		HL
		LD		A,(HL)
		XOR		$55
		OR		C
		LD		C,A
		INC		L
		JR		NZ,@0b
		INC		H
		LD		A,B
		CP		H
		JR		NZ,@0b
		RET

check_dram_row_Match_C: ; TODO!!!
		LD		C,0
		RET

kbd_read_space:
		LD		HL,$E000		; port A to select keyboard matrix column
		LD		DE,$E001		; port B to read keyboard matrix row
		LD		B,$F0+4			; matrix column 4 ([SPACE] MZ-80 A)
		LD		(HL),B			; select keyboard matrix column containing SPACE key
		LD		A,(DE)			; read keyboard matrix row
		CPL
		AND		$01				; SPACE bit
		LD		C,A
		LD		B,$F0+9			; matrix column 9 ([SPACE] MZ-80 K)
		LD		(HL),B			; select keyboard matrix column containing [<-/->] arrows keys
		LD		A,(DE)			; read keyboard matrix row
		CPL
		AND		$02				; SPACE bit
		OR		C
		RET

; -----------------------------------------------------------------------------
; ZX0 decoder by Einar Saukas & Urusergi
; "Standard" version (68 bytes only)
; -----------------------------------------------------------------------------
; Parameters:
;   HL: source address (compressed data)
;   DE: destination address (decompressing)
; -----------------------------------------------------------------------------

dzx0_standard:
		LD		BC,$FFFF				; preserve default offset 1
		PUSH	BC
		INC		BC
		LD		A,$80
dzx0s_literals:
		CALL	dzx0s_elias				; obtain length
		LDIR							; copy literals
		ADD		A,A						; copy from last offset or new offset?
		JR		C,dzx0s_new_offset
		CALL	dzx0s_elias				; obtain length
dzx0s_copy:
		EX		(SP),HL					; preserve source, restore offset
		PUSH	HL						; preserve offset
		ADD		HL,DE					; calculate destination - offset
		LDIR							; copy from offset
		POP		HL						; restore offset
		EX		(SP),HL					; preserve offset, restore source
		ADD		A,A						; copy from literals or new offset?
		JR		NC,dzx0s_literals
dzx0s_new_offset:
		POP		BC						; discard last offset
		LD		C,$FE					; prepare negative offset
		CALL	dzx0s_elias_loop		; obtain offset MSB
		INC		C
		RET		Z						; check end marker
		LD		B,C
		LD		C,(HL)					; obtain offset LSB
		INC		HL
		RR		B						; last offset bit becomes first length bit
		RR		C
		PUSH	BC						; preserve new offset
		LD		BC,1					; obtain length
		CALL	NC,dzx0s_elias_backtrack
		INC		BC
		JR		dzx0s_copy
dzx0s_elias:
		INC		C						; interlaced Elias gamma coding
dzx0s_elias_loop:
		ADD		A,A
		JR		NZ,dzx0s_elias_skip
		LD		A,(HL)					; load another group of 8 bits
		INC		HL
		RLA
dzx0s_elias_skip:
		RET		C
dzx0s_elias_backtrack:
		ADD		A,A
		RL		C
		RL		B
		JR		dzx0s_elias_loop
; -----------------------------------------------------------------------------

vram_test_screen0:
		binclude gfx/DRAMTester_screen0.0.zx0 
vram_test_screen1:
		binclude gfx/DRAMTester_screen0.1.zx0 
vram_dram_screen:
		binclude gfx/DRAMTester_screen1.0.zx0 

		DS	$1000 - $
; -----------------------------------------------------------------------------
END	mrom_main
