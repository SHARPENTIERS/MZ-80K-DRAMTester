ORG 			$0000

; -----------------------------------------------------------------------------
; Definitions
; -----------
CHRMAP			"DISPLAYCODE-EU"

; -----------------------------------------------------------------------------
; Main entry
; ----------
mrom_main:
		; No interrupt
		DI
		LD		SP,$E000

		; Draw test screen #0
loop:	LD		HL,vram_test_screen0
		LD		DE,$D000
		CALL	dzx0_standard

@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b

		CALL	wait_space_bar
		
		; Draw DRAM screen
		LD		HL,vram_dram_screen
		LD		DE,$D000
		CALL	dzx0_standard

loop0:	LD		HL,$D000
		LD		(HL),32

		CALL	wait_vsync

		; Check DRAM chips in area $1000-$4FFF - DRAM (I) - 16K x 8bit
check_dram_row_I_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$5000
		LD		HL,$1000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_I

		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		NZ,exit0

		CALL	wait_vsync

		; Check DRAM chips in area $5000-$8FFF - DRAM (II) - 16K x 8bit
check_dram_row_II_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$9000
		LD		HL,$5000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_II

		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		NZ,exit0

		CALL	wait_vsync

		; Check DRAM chips in area $9000-$CFFF - DRAM (III) - 16K x 8bit
check_dram_row_III_55_AA_RW:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$D000
		LD		HL,$9000
		CALL	check_dram_row_55_AA_RW
		CALL	draw_dram_row_III

		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		Z,loop0

exit0:
		; Draw test screen #1
		LD		HL,vram_test_screen1
		LD		DE,$D000
		CALL	dzx0_standard

@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b

		CALL	wait_space_bar

		; Draw DRAM screen
		LD		HL,vram_dram_screen
		LD		DE,$D000
		CALL	dzx0_standard

loop1:	LD		HL,$D000
		LD		(HL),32

		CALL	wait_vsync
		
		; Check DRAM chips in area $1000-$4FFF - DRAM (I)
check_dram_row_I_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$5000
		LD		HL,$1000
		CALL	check_dram_row_Match_C  
		CALL	draw_dram_row_I

		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		NZ,exit1

		CALL	wait_vsync

		; Check DRAM chips in area $5000-$8FFF - DRAM (II)
check_dram_row_II_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$9000
		LD		HL,$5000
		CALL	check_dram_row_Match_C
		CALL	draw_dram_row_II

		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		NZ,exit1

		CALL	wait_vsync

		; Check DRAM chips in area $9000-$CFFF - DRAM (III)
check_dram_row_III_March_C:
		LD		HL,$D000
		INC		(HL)
		LD		BC,$D000
		LD		HL,$9000
		CALL	check_dram_row_Match_C
		CALL	draw_dram_row_III

@@:		CALL	kbd_read_space			; wait for pressing [SPACE] to stop looping 
		JR		Z,loop1

exit1:
		JP		loop

draw_dram_row:
		; BIT D0 is OK/KO?
		BIT		0,C
		LD		HL,$D000+(2*40)
		CALL	draw_dram_bit_state
		; BIT D1 is OK/KO?
		BIT		1,C
		LD		HL,$D000+(5*40)
		CALL	draw_dram_bit_state
		; BIT D2 is OK/KO?
		BIT		2,C
		LD		HL,$D000+(8*40)
		CALL	draw_dram_bit_state
		; BIT D3 is OK/KO?
		BIT		3,C
		LD		HL,$D000+(11*40)
		CALL	draw_dram_bit_state
		; BIT D4 is OK/KO?
		BIT		4,C
		LD		HL,$D000+(14*40)
		CALL	draw_dram_bit_state
		; BIT D5 is OK/KO?
		BIT		5,C
		LD		HL,$D000+(17*40)
		CALL	draw_dram_bit_state
		; BIT D6 is OK/KO?
		BIT		6,C
		LD		HL,$D000+(20*40)
		CALL	draw_dram_bit_state
		; BIT D7 is OK/KO?
		BIT		7,C
		LD		HL,$D000+(23*40)
		CALL	draw_dram_bit_state
		RET

draw_dram_bit_state:
		LD		A,$47 ; OK
		JR		Z,@f
		LD		A,$6D ; KO
@@:		ADD		HL,DE
		LD		(HL),A
		RET

draw_dram_row_I:
		LD		DE,34
		JP		draw_dram_row

draw_dram_row_II:
		LD		DE,23
		JP		draw_dram_row

draw_dram_row_III:
		LD		DE,11
		JP		draw_dram_row

wait_vsync:
		LD		HL,$E002
		LD		A,$7F					; C = ($E002) > $7F <=> $E002.bit7 == 0
@@:		CP		(HL)					; poll /VBLK until it becomes low (asserted)
		JP		C,@b
		RET

wait_space_bar:
@@:		CALL	kbd_read_space			; wait for holding [SPACE]
		JR		Z,@b
@@:		CALL	kbd_read_space			; wait for releasing [SPACE]
		JR		NZ,@b
		RET

check_dram_row_55_AA_RW:
@@:		LD		(HL),$55
		INC		HL
		LD		(HL),$AA
		DEC		HL
		LD		A,(HL)
		XOR		$55
		OR		C
		LD		C,A
		INC		HL
		LD		A,(HL)
		XOR		$AA
		OR		C
		LD		C,A
		DEC		HL
		LD		(HL),$AA
		INC		HL
		LD		(HL),$55
		DEC		HL
		LD		A,(HL)
		XOR		$AA
		OR		C
		LD		C,A
		INC		HL
		LD		A,(HL)
		XOR		$55
		OR		C
		LD		C,A
		CALL	loopable_from_xx00_to_xxFF
		JP		NZ,@b
		RET

check_dram_row_Match_C:
		LD		C,0
		LD		D,H
		LD		E,H
		DEC		E

		; RAM clearance in the row
@@:		LD		(HL),0
		CALL	loopable_from_xx00_to_xxFF
		JR		NZ,@b

		LD		H,D
		; W/R check of '1' from the address head / from LSB to MSB bits
@@:		CALL	bitcheck_r0_w1
		CALL	loopable_from_xx00_to_xxFF
		JR		NZ,@b

		LD		H,D
		; W/R check of '0' from the address head / from LSB to MSB bits
@@:		CALL	bitcheck_r1_w0
		CALL	loopable_from_xx00_to_xxFF
		JR		NZ,@b
		
		LD		H,B
		DEC		HL ; we want the last byte address, not the end address
		; W/R check of '1' from the address tail / from LSB to MSB bits
@@:		CALL	bitcheck_r0_w1
		DEC		L
		JR		NZ,@b	; loop from xxFF to xx00 -> ends with xx00
		CALL	bitcheck_r0_w1
		DEC		H
		LD		A,E
		CP		H
		JR		NZ,@b
		
		LD		H,B
		DEC		HL ; we want the last byte address, not the end address
		; W/R check of '0' from the address tail / from LSB to MSB bits
@@:		CALL	bitcheck_r1_w0
		DEC		L
		JR		NZ,@b	; loop from xxFF to xx00 -> ends with xx00
		CALL	bitcheck_r1_w0
		DEC		H
		LD		A,E
		CP		H
		JR		NZ,@b

		LD		H,D
		; Check bytes are all '0' in the row
@@:		LD		A,(HL)
		OR		C
		CALL	loopable_from_xx00_to_xxFF
		JR		NZ,@b

		RET

loopable_from_xx00_to_xxFF:
		INC		L
		RET		NZ ; loop from xx00 to xxFF -> ends with xx00
		INC		H
		LD		A,B
		CP		H
		RET

bitcheck_r0_w1:
		LD		A,(HL) ; check all bits are set to "0"
		OR		C
		SET		0,(HL) ; set bit 0 and check bit 0 is set
		LD		A,(HL)
		XOR		$01
		OR		C
		SET		1,(HL) ; set bit 1 and check bits 0..1 are set
		LD		A,(HL)
		XOR		$03
		OR		C
		SET		2,(HL) ; set bit 2 and check bits 0..2 are set
		LD		A,(HL)
		XOR		$07
		OR		C
		SET		3,(HL) ; set bit 3 and check bits 0..3 are set
		LD		A,(HL)
		XOR		$0F
		OR		C
		SET		4,(HL) ; set bit 4 and check bits 0..4 are set
		LD		A,(HL)
		XOR		$1F
		OR		C
		SET		5,(HL) ; set bit 5 and check bits 0..5 are set
		LD		A,(HL)
		XOR		$3F
		OR		C
		SET		6,(HL) ; set bit 6 and check bits 0..6 are set
		LD		A,(HL)
		XOR		$7F
		OR		C
		SET		7,(HL) ; set bit 7 and check bits 0..7 are set
		LD		A,(HL)
		XOR		$FF
		OR		C
		RET

bitcheck_r1_w0:
		LD		A,(HL) ; check all bits are set to "1"
		XOR		$FF
		OR		C
		RES		0,(HL) ; clear bit 0 and check bit 0 is cleared
		LD		A,(HL)
		XOR		$FE
		OR		C
		RES		1,(HL) ; clear bit 1 and check bits 0..1 are cleared
		LD		A,(HL)
		XOR		$FC
		OR		C
		RES		2,(HL) ; clear bit 2 and check bits 0..2 are cleared
		LD		A,(HL)
		XOR		$F8
		OR		C
		RES		3,(HL) ; clear bit 3 and check bits 0..3 are cleared
		LD		A,(HL)
		XOR		$F0
		OR		C
		RES		4,(HL) ; clear bit 4 and check bits 0..4 are cleared
		LD		A,(HL)
		XOR		$E0
		OR		C
		RES		5,(HL) ; clear bit 5 and check bits 0..5 are cleared
		LD		A,(HL)
		XOR		$C0
		OR		C
		RES		6,(HL) ; clear bit 6 and check bits 0..6 are cleared
		LD		A,(HL)
		XOR		$80
		OR		C
		RES		7,(HL) ; clear bit 7 and check bits 0..7 are cleared
		LD		A,(HL)
		OR		C
		RET

kbd_read_space:
		LD		HL,$E000		; port A to select keyboard matrix column
		LD		DE,$E001		; port B to read keyboard matrix row
		LD		B,$F0+4			; matrix column 4 ([SPACE] MZ-80 A)
		LD		(HL),B			; select keyboard matrix column containing SPACE key
		LD		A,(DE)			; read keyboard matrix row
		CPL
		AND		$01				; SPACE bit
		LD		C,A
		LD		B,$F0+9			; matrix column 9 ([SPACE] MZ-80 K)
		LD		(HL),B			; select keyboard matrix column containing [<-/->] arrows keys
		LD		A,(DE)			; read keyboard matrix row
		CPL
		AND		$02				; SPACE bit
		OR		C
		RET

; -----------------------------------------------------------------------------
; ZX0 decoder by Einar Saukas & Urusergi
; "Standard" version (68 bytes only)
; -----------------------------------------------------------------------------
; Parameters:
;   HL: source address (compressed data)
;   DE: destination address (decompressing)
; -----------------------------------------------------------------------------

dzx0_standard:
		LD		BC,$FFFF				; preserve default offset 1
		PUSH	BC
		INC		BC
		LD		A,$80
dzx0s_literals:
		CALL	dzx0s_elias				; obtain length
		LDIR							; copy literals
		ADD		A,A						; copy from last offset or new offset?
		JR		C,dzx0s_new_offset
		CALL	dzx0s_elias				; obtain length
dzx0s_copy:
		EX		(SP),HL					; preserve source, restore offset
		PUSH	HL						; preserve offset
		ADD		HL,DE					; calculate destination - offset
		LDIR							; copy from offset
		POP		HL						; restore offset
		EX		(SP),HL					; preserve offset, restore source
		ADD		A,A						; copy from literals or new offset?
		JR		NC,dzx0s_literals
dzx0s_new_offset:
		POP		BC						; discard last offset
		LD		C,$FE					; prepare negative offset
		CALL	dzx0s_elias_loop		; obtain offset MSB
		INC		C
		RET		Z						; check end marker
		LD		B,C
		LD		C,(HL)					; obtain offset LSB
		INC		HL
		RR		B						; last offset bit becomes first length bit
		RR		C
		PUSH	BC						; preserve new offset
		LD		BC,1					; obtain length
		CALL	NC,dzx0s_elias_backtrack
		INC		BC
		JR		dzx0s_copy
dzx0s_elias:
		INC		C						; interlaced Elias gamma coding
dzx0s_elias_loop:
		ADD		A,A
		JR		NZ,dzx0s_elias_skip
		LD		A,(HL)					; load another group of 8 bits
		INC		HL
		RLA
dzx0s_elias_skip:
		RET		C
dzx0s_elias_backtrack:
		ADD		A,A
		RL		C
		RL		B
		JR		dzx0s_elias_loop
; -----------------------------------------------------------------------------

vram_test_screen0:
		binclude gfx/DRAMTester_screen0.0.zx0 
vram_test_screen1:
		binclude gfx/DRAMTester_screen0.1.zx0 
vram_dram_screen:
		binclude gfx/DRAMTester_screen1.0.zx0 

		DS	$1000 - $
; -----------------------------------------------------------------------------
END	mrom_main
